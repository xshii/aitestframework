#!/usr/bin/env python3
"""Generate a C source file with embedded weight data from a manifest.

Manifest format:
    base_addr  swap_word_size      <- header: start a new group
    bin_file                       <- entry (file size auto-detected)
    bin_file
    base_addr  swap_word_size      <- next group
    bin_file

Lines starting with # are comments. Blank lines are ignored.
When embedding, endian swap is applied at generation time.
"""

import sys
import os
import re


def sanitize(name):
    """Convert filename to a valid C identifier."""
    name = os.path.splitext(os.path.basename(name))[0]
    return re.sub(r'[^a-zA-Z0-9_]', '_', name)


def swap_bytes(data, word_size):
    """Swap endianness of each word_size-byte block in data."""
    out = bytearray(len(data))
    for i in range(0, len(data) - word_size + 1, word_size):
        word = data[i:i + word_size]
        out[i:i + word_size] = word[::-1]
    return bytes(out)


def main():
    if len(sys.argv) != 4:
        print(f"Usage: {sys.argv[0]} <manifest> <base_dir> <output.c>",
              file=sys.stderr)
        sys.exit(1)

    manifest_path = sys.argv[1]
    base_dir = sys.argv[2]
    output_path = sys.argv[3]

    # groups: list of (base_addr, [(bin_file, data), ...])
    groups = []
    cur_group = None

    with open(manifest_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split()
            if len(parts) == 2:
                # header line
                addr_str = parts[0]
                base_addr = int(addr_str, 16) if addr_str.startswith('0x') \
                    else int(addr_str)
                swap_word = int(parts[1])
                if swap_word not in (0, 2, 4, 8):
                    print(f"Invalid swap {swap_word} (must be 0/2/4/8)",
                          file=sys.stderr)
                    sys.exit(1)
                cur_group = (base_addr, swap_word, [])
                groups.append(cur_group)
            elif len(parts) == 1:
                # entry line
                if cur_group is None:
                    print(f"Entry before header: {line}", file=sys.stderr)
                    sys.exit(1)
                bin_file = parts[0]
                if os.path.isabs(bin_file):
                    bin_path = bin_file
                else:
                    bin_path = os.path.join(base_dir, bin_file)
                with open(bin_path, 'rb') as bf:
                    data = bf.read()
                if len(data) == 0:
                    print(f"Empty file: {bin_path}", file=sys.stderr)
                    sys.exit(1)
                _, swap_word, entries = cur_group
                if swap_word >= 2:
                    data = swap_bytes(data, swap_word)
                entries.append((bin_file, data))
            else:
                print(f"Bad line: {line}", file=sys.stderr)
                sys.exit(1)

    if not groups:
        print("Manifest has no groups", file=sys.stderr)
        sys.exit(1)

    os.makedirs(os.path.dirname(output_path) or '.', exist_ok=True)

    # flatten all entries for array generation
    all_entries = []
    for base_addr, swap_word, entries in groups:
        for bin_file, data in entries:
            all_entries.append((bin_file, data, len(data)))

    with open(output_path, 'w') as out:
        out.write("/* Auto-generated by embed_weights.py â€” do not edit */\n")
        out.write("#include \"stub_memmap.h\"\n")
        out.write("#include \"stub_log.h\"\n")
        out.write("#include <stddef.h>\n\n")

        # data arrays
        for idx, (bin_file, data, size) in enumerate(all_entries):
            cname = sanitize(bin_file)
            out.write(f"static const unsigned char _embed_{idx}_{cname}"
                      f"[{size}] = {{\n")
            for i in range(0, len(data), 16):
                chunk = data[i:i + 16]
                hex_str = ", ".join(f"0x{b:02X}" for b in chunk)
                out.write(f"    {hex_str},\n")
            out.write("};\n\n")

        # entry table
        out.write("typedef struct {\n")
        out.write("    const unsigned char *data;\n")
        out.write("    size_t              size;\n")
        out.write("} weight_embed_entry_t;\n\n")

        out.write("static const weight_embed_entry_t s_embed_entries[] = {\n")
        for idx, (bin_file, data, size) in enumerate(all_entries):
            cname = sanitize(bin_file)
            out.write(f"    {{_embed_{idx}_{cname}, {size}}},\n")
        out.write("};\n\n")

        # group table
        out.write("typedef struct {\n")
        out.write("    unsigned int base_addr;\n")
        out.write("    int          start;\n")
        out.write("    int          count;\n")
        out.write("} weight_embed_group_t;\n\n")

        out.write("static const weight_embed_group_t s_embed_groups[] = {\n")
        entry_idx = 0
        for base_addr, swap_word, entries in groups:
            cnt = len(entries)
            out.write(f"    {{0x{base_addr:08X}, {entry_idx}, {cnt}}},\n")
            entry_idx += cnt
        out.write("};\n\n")

        out.write(f"static const int s_embed_group_count = {len(groups)};\n\n")

        # weight_load_embedded()
        out.write("int weight_load_embedded(void)\n{\n")
        out.write("    for (int g = 0; g < s_embed_group_count; g++) {\n")
        out.write("        const weight_embed_group_t *grp = "
                  "&s_embed_groups[g];\n")
        out.write("        unsigned int dst = grp->base_addr;\n")
        out.write("        for (int i = grp->start; "
                  "i < grp->start + grp->count; i++) {\n")
        out.write("            const weight_embed_entry_t *e = "
                  "&s_embed_entries[i];\n")
        out.write("            int rc = memmap_write(dst, e->data, "
                  "e->size);\n")
        out.write("            if (rc != 0) {\n")
        out.write('                LOG_ERROR("weight_embed: '
                  'memmap_write failed at 0x%08X", dst);\n')
        out.write("                return rc;\n")
        out.write("            }\n")
        out.write("            dst += (unsigned int)e->size;\n")
        out.write("        }\n")
        out.write("    }\n")
        total = sum(len(entries) for _, _, entries in groups)
        out.write(f'    LOG_INFO("weight_embed: loaded {total} tensors '
                  f'in {len(groups)} groups");\n')
        out.write("    return 0;\n")
        out.write("}\n")

    print(f"Embedded {len(all_entries)} tensors in {len(groups)} groups "
          f"into {output_path}")


if __name__ == '__main__':
    main()
