#include "stub_registry.h"
#include "stub_config.h"
#include "stub_log.h"
#include "stub_memmap.h"
#include "stub_weight.h"
#include "platform_api.h"
#include <string.h>

extern const model_entry_t g_model_table[];
extern const int           g_model_table_count;

/* Compile-time default run list (generated by CMake, empty = run all) */
extern const char *g_default_run_models[];
extern const int   g_default_run_count;

static int match_name(const char *name, const char *list[], int count)
{
    for (int j = 0; j < count; j++)
        if (strcmp(list[j], name) == 0) return 1;
    return 0;
}

static int should_run(const char *name, const stub_config_t *cfg)
{
    if (cfg->model_count > 0) {
        for (int j = 0; j < cfg->model_count; j++)
            if (strcmp(cfg->model_names[j], name) == 0) return 1;
        return 0;
    }
    if (g_default_run_count > 0)
        return match_name(name, (const char **)g_default_run_models,
                          g_default_run_count);
    return 1; /* run all */
}

/* Hardcoded entry point — platform calls this after registering hooks */
int stub_entry(int argc, char *argv[])
{
    stub_config_t cfg;
    int rc = stub_config_parse(argc, argv, &cfg);
    if (rc != 0) return (rc > 0) ? 0 : 1;

    stub_registry_init(g_model_table, g_model_table_count);

    if (cfg.list_models) {
        const model_entry_t *all = stub_registry_get_all();
        for (int i = 0; i < stub_registry_count(); i++)
            printf("  %s\n", all[i].name);
        return 0;
    }

    /* reset memmap before any model setup */
    memmap_reset();

#ifndef EMBED_WEIGHTS
    /* parse weight manifest if provided (file-based path) */
    weight_manifest_t wm;
    int has_weights = 0;
    if (cfg.weight_manifest[0] != '\0') {
        rc = weight_parse(cfg.weight_manifest, cfg.weight_dir, &wm);
        if (rc != 0) return 1;
        has_weights = 1;
    }
#endif

    int n = stub_registry_count();
    const model_entry_t *all = stub_registry_get_all();
    int failed = 0;

    for (int i = 0; i < n; i++) {
        if (!should_run(all[i].name, &cfg)) continue;

        LOG_INFO("running: %s", all[i].name);

        /* setup: register memmap regions */
        if (all[i].setup) {
            rc = all[i].setup(&cfg);
            if (rc != 0) {
                LOG_ERROR("%s setup FAILED (rc=%d)", all[i].name, rc);
                failed++;
                continue;
            }
        }

        /* load weights into registered regions */
#ifdef EMBED_WEIGHTS
        rc = weight_load_embedded();
        if (rc != 0) {
            LOG_ERROR("%s embedded weight load FAILED (rc=%d)", all[i].name, rc);
            failed++;
            continue;
        }
#else
        if (has_weights) {
            rc = weight_load_all(&wm);
            if (rc != 0) {
                LOG_ERROR("%s weight load FAILED (rc=%d)", all[i].name, rc);
                failed++;
                continue;
            }
        }
#endif

        /* run model */
        rc = all[i].run(&cfg);
        if (rc != 0) { LOG_ERROR("%s FAILED (rc=%d)", all[i].name, rc); failed++; }
        else         { LOG_INFO("%s PASSED", all[i].name); }
    }
    return failed ? 1 : 0;
}

/* Hardcoded exit point — platform calls this on unload (-X) */
void stub_exit(void)
{
    LOG_INFO("stub_exit: cleanup done");
}
